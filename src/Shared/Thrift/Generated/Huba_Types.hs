{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (0.9.1)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module Huba_Types where
import Prelude ( Bool(..), Enum, Double, String, Maybe(..),
                 Eq, Show, Ord,
                 return, length, IO, fromIntegral, fromEnum, toEnum,
                 (.), (&&), (||), (==), (++), ($), (-) )

import Control.Exception
import Data.ByteString.Lazy
import Data.Hashable
import Data.Int
import Data.Text.Lazy ( Text )
import qualified Data.Text.Lazy as TL
import Data.Typeable ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector

import Thrift
import Thrift.Types ()


data AggregationFunction = CONSTANT|COUNT|MIN|MAX|SUM|AVERAGE|SUM_PER_MINUTE|HISTOGRAM  deriving (Show,Eq, Typeable, Ord)
instance Enum AggregationFunction where
  fromEnum t = case t of
    CONSTANT -> 0
    COUNT -> 1
    MIN -> 2
    MAX -> 3
    SUM -> 4
    AVERAGE -> 5
    SUM_PER_MINUTE -> 6
    HISTOGRAM -> 7
  toEnum t = case t of
    0 -> CONSTANT
    1 -> COUNT
    2 -> MIN
    3 -> MAX
    4 -> SUM
    5 -> AVERAGE
    6 -> SUM_PER_MINUTE
    7 -> HISTOGRAM
    _ -> throw ThriftException
instance Hashable AggregationFunction where
  hashWithSalt salt = hashWithSalt salt . fromEnum
data ComparisonFunction = EQ|NEQ|REGEXP_EQ|GT|LT|GTE|LTE  deriving (Show,Eq, Typeable, Ord)
instance Enum ComparisonFunction where
  fromEnum t = case t of
    EQ -> 1
    NEQ -> 2
    REGEXP_EQ -> 3
    GT -> 4
    LT -> 5
    GTE -> 6
    LTE -> 7
  toEnum t = case t of
    1 -> EQ
    2 -> NEQ
    3 -> REGEXP_EQ
    4 -> GT
    5 -> LT
    6 -> GTE
    7 -> LTE
    _ -> throw ThriftException
instance Hashable ComparisonFunction where
  hashWithSalt salt = hashWithSalt salt . fromEnum
type ColumnName = Text

type ServerID = Int32

type Row = Vector.Vector ResponseValue

data ColumnValue = ColumnValue{f_ColumnValue_stringValue :: Maybe Text,f_ColumnValue_intValue :: Maybe Int64,f_ColumnValue_stringSet :: Maybe (Set.HashSet Text),f_ColumnValue_stringVector :: Maybe (Vector.Vector Text)} deriving (Show,Eq,Typeable)
instance Hashable ColumnValue where
  hashWithSalt salt record = salt   `hashWithSalt` f_ColumnValue_stringValue record   `hashWithSalt` f_ColumnValue_intValue record   `hashWithSalt` f_ColumnValue_stringSet record   `hashWithSalt` f_ColumnValue_stringVector record  
write_ColumnValue oprot record = do
  writeStructBegin oprot "ColumnValue"
  case f_ColumnValue_stringValue record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("stringValue",T_STRING,1)
    writeString oprot _v
    writeFieldEnd oprot}
  case f_ColumnValue_intValue record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("intValue",T_I64,2)
    writeI64 oprot _v
    writeFieldEnd oprot}
  case f_ColumnValue_stringSet record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("stringSet",T_SET,3)
    (let {f [] = return (); f (_viter2:t) = do {writeString oprot _viter2;f t}} in do {writeSetBegin oprot (T_STRING,fromIntegral $ Set.size _v); f (Set.toList _v);writeSetEnd oprot})
    writeFieldEnd oprot}
  case f_ColumnValue_stringVector record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("stringVector",T_LIST,4)
    (let f = Vector.mapM_ (\_viter3 -> writeString oprot _viter3) in do {writeListBegin oprot (T_STRING,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_ColumnValue_fields iprot record = do
  (_,_t5,_id6) <- readFieldBegin iprot
  if _t5 == T_STOP then return record else
    case _id6 of 
      1 -> if _t5 == T_STRING then do
        s <- readString iprot
        read_ColumnValue_fields iprot record{f_ColumnValue_stringValue=Just s}
        else do
          skip iprot _t5
          read_ColumnValue_fields iprot record
      2 -> if _t5 == T_I64 then do
        s <- readI64 iprot
        read_ColumnValue_fields iprot record{f_ColumnValue_intValue=Just s}
        else do
          skip iprot _t5
          read_ColumnValue_fields iprot record
      3 -> if _t5 == T_SET then do
        s <- (let {f 0 = return []; f n = do {v <- readString iprot;r <- f (n-1); return $ v:r}} in do {(_etype10,_size7) <- readSetBegin iprot; l <- f _size7; return $ Set.fromList l})
        read_ColumnValue_fields iprot record{f_ColumnValue_stringSet=Just s}
        else do
          skip iprot _t5
          read_ColumnValue_fields iprot record
      4 -> if _t5 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) (readString iprot) in do {(_etype15,_size12) <- readListBegin iprot; f _size12})
        read_ColumnValue_fields iprot record{f_ColumnValue_stringVector=Just s}
        else do
          skip iprot _t5
          read_ColumnValue_fields iprot record
      _ -> do
        skip iprot _t5
        readFieldEnd iprot
        read_ColumnValue_fields iprot record
read_ColumnValue iprot = do
  _ <- readStructBegin iprot
  record <- read_ColumnValue_fields iprot (ColumnValue{f_ColumnValue_stringValue=Nothing,f_ColumnValue_intValue=Nothing,f_ColumnValue_stringSet=Nothing,f_ColumnValue_stringVector=Nothing})
  readStructEnd iprot
  return record
data LogMessage = LogMessage{f_LogMessage_timestamp :: Maybe Int64,f_LogMessage_table :: Maybe Text,f_LogMessage_columns :: Maybe (Map.HashMap Text ColumnValue)} deriving (Show,Eq,Typeable)
instance Hashable LogMessage where
  hashWithSalt salt record = salt   `hashWithSalt` f_LogMessage_timestamp record   `hashWithSalt` f_LogMessage_table record   `hashWithSalt` f_LogMessage_columns record  
write_LogMessage oprot record = do
  writeStructBegin oprot "LogMessage"
  case f_LogMessage_timestamp record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("timestamp",T_I64,1)
    writeI64 oprot _v
    writeFieldEnd oprot}
  case f_LogMessage_table record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("table",T_STRING,2)
    writeString oprot _v
    writeFieldEnd oprot}
  case f_LogMessage_columns record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("columns",T_MAP,3)
    (let {f [] = return (); f ((_kiter19,_viter20):t) = do {do {writeString oprot _kiter19;write_ColumnValue oprot _viter20};f t}} in do {writeMapBegin oprot (T_STRING,T_STRUCT,fromIntegral $ Map.size _v); f (Map.toList _v);writeMapEnd oprot})
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_LogMessage_fields iprot record = do
  (_,_t22,_id23) <- readFieldBegin iprot
  if _t22 == T_STOP then return record else
    case _id23 of 
      1 -> if _t22 == T_I64 then do
        s <- readI64 iprot
        read_LogMessage_fields iprot record{f_LogMessage_timestamp=Just s}
        else do
          skip iprot _t22
          read_LogMessage_fields iprot record
      2 -> if _t22 == T_STRING then do
        s <- readString iprot
        read_LogMessage_fields iprot record{f_LogMessage_table=Just s}
        else do
          skip iprot _t22
          read_LogMessage_fields iprot record
      3 -> if _t22 == T_MAP then do
        s <- (let {f 0 = return []; f n = do {k <- readString iprot; v <- (read_ColumnValue iprot);r <- f (n-1); return $ (k,v):r}} in do {(_ktype25,_vtype26,_size24) <- readMapBegin iprot; l <- f _size24; return $ Map.fromList l})
        read_LogMessage_fields iprot record{f_LogMessage_columns=Just s}
        else do
          skip iprot _t22
          read_LogMessage_fields iprot record
      _ -> do
        skip iprot _t22
        readFieldEnd iprot
        read_LogMessage_fields iprot record
read_LogMessage iprot = do
  _ <- readStructBegin iprot
  record <- read_LogMessage_fields iprot (LogMessage{f_LogMessage_timestamp=Nothing,f_LogMessage_table=Nothing,f_LogMessage_columns=Nothing})
  readStructEnd iprot
  return record
data LogResponse = LogResponse{f_LogResponse_code :: Maybe Int32,f_LogResponse_message :: Maybe Text} deriving (Show,Eq,Typeable)
instance Hashable LogResponse where
  hashWithSalt salt record = salt   `hashWithSalt` f_LogResponse_code record   `hashWithSalt` f_LogResponse_message record  
write_LogResponse oprot record = do
  writeStructBegin oprot "LogResponse"
  case f_LogResponse_code record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("code",T_I32,1)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_LogResponse_message record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("message",T_STRING,2)
    writeString oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_LogResponse_fields iprot record = do
  (_,_t32,_id33) <- readFieldBegin iprot
  if _t32 == T_STOP then return record else
    case _id33 of 
      1 -> if _t32 == T_I32 then do
        s <- readI32 iprot
        read_LogResponse_fields iprot record{f_LogResponse_code=Just s}
        else do
          skip iprot _t32
          read_LogResponse_fields iprot record
      2 -> if _t32 == T_STRING then do
        s <- readString iprot
        read_LogResponse_fields iprot record{f_LogResponse_message=Just s}
        else do
          skip iprot _t32
          read_LogResponse_fields iprot record
      _ -> do
        skip iprot _t32
        readFieldEnd iprot
        read_LogResponse_fields iprot record
read_LogResponse iprot = do
  _ <- readStructBegin iprot
  record <- read_LogResponse_fields iprot (LogResponse{f_LogResponse_code=Nothing,f_LogResponse_message=Nothing})
  readStructEnd iprot
  return record
data InvalidLogMessageException = InvalidLogMessageException{f_InvalidLogMessageException_code :: Maybe Int32,f_InvalidLogMessageException_message :: Maybe Text} deriving (Show,Eq,Typeable)
instance Exception InvalidLogMessageException
instance Hashable InvalidLogMessageException where
  hashWithSalt salt record = salt   `hashWithSalt` f_InvalidLogMessageException_code record   `hashWithSalt` f_InvalidLogMessageException_message record  
write_InvalidLogMessageException oprot record = do
  writeStructBegin oprot "InvalidLogMessageException"
  case f_InvalidLogMessageException_code record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("code",T_I32,1)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_InvalidLogMessageException_message record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("message",T_STRING,2)
    writeString oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_InvalidLogMessageException_fields iprot record = do
  (_,_t37,_id38) <- readFieldBegin iprot
  if _t37 == T_STOP then return record else
    case _id38 of 
      1 -> if _t37 == T_I32 then do
        s <- readI32 iprot
        read_InvalidLogMessageException_fields iprot record{f_InvalidLogMessageException_code=Just s}
        else do
          skip iprot _t37
          read_InvalidLogMessageException_fields iprot record
      2 -> if _t37 == T_STRING then do
        s <- readString iprot
        read_InvalidLogMessageException_fields iprot record{f_InvalidLogMessageException_message=Just s}
        else do
          skip iprot _t37
          read_InvalidLogMessageException_fields iprot record
      _ -> do
        skip iprot _t37
        readFieldEnd iprot
        read_InvalidLogMessageException_fields iprot record
read_InvalidLogMessageException iprot = do
  _ <- readStructBegin iprot
  record <- read_InvalidLogMessageException_fields iprot (InvalidLogMessageException{f_InvalidLogMessageException_code=Nothing,f_InvalidLogMessageException_message=Nothing})
  readStructEnd iprot
  return record
data ColumnExpression = ColumnExpression{f_ColumnExpression_column :: Maybe Text,f_ColumnExpression_aggregationFunction :: Maybe AggregationFunction} deriving (Show,Eq,Typeable)
instance Hashable ColumnExpression where
  hashWithSalt salt record = salt   `hashWithSalt` f_ColumnExpression_column record   `hashWithSalt` f_ColumnExpression_aggregationFunction record  
write_ColumnExpression oprot record = do
  writeStructBegin oprot "ColumnExpression"
  case f_ColumnExpression_column record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("column",T_STRING,1)
    writeString oprot _v
    writeFieldEnd oprot}
  case f_ColumnExpression_aggregationFunction record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("aggregationFunction",T_I32,2)
    writeI32 oprot (fromIntegral $ fromEnum _v)
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_ColumnExpression_fields iprot record = do
  (_,_t42,_id43) <- readFieldBegin iprot
  if _t42 == T_STOP then return record else
    case _id43 of 
      1 -> if _t42 == T_STRING then do
        s <- readString iprot
        read_ColumnExpression_fields iprot record{f_ColumnExpression_column=Just s}
        else do
          skip iprot _t42
          read_ColumnExpression_fields iprot record
      2 -> if _t42 == T_I32 then do
        s <- (do {i <- readI32 iprot; return $ toEnum $ fromIntegral i})
        read_ColumnExpression_fields iprot record{f_ColumnExpression_aggregationFunction=Just s}
        else do
          skip iprot _t42
          read_ColumnExpression_fields iprot record
      _ -> do
        skip iprot _t42
        readFieldEnd iprot
        read_ColumnExpression_fields iprot record
read_ColumnExpression iprot = do
  _ <- readStructBegin iprot
  record <- read_ColumnExpression_fields iprot (ColumnExpression{f_ColumnExpression_column=Nothing,f_ColumnExpression_aggregationFunction=Nothing})
  readStructEnd iprot
  return record
data Condition = Condition{f_Condition_column :: Maybe Text,f_Condition_comparisonFunction :: Maybe ComparisonFunction,f_Condition_value :: Maybe ColumnValue} deriving (Show,Eq,Typeable)
instance Hashable Condition where
  hashWithSalt salt record = salt   `hashWithSalt` f_Condition_column record   `hashWithSalt` f_Condition_comparisonFunction record   `hashWithSalt` f_Condition_value record  
write_Condition oprot record = do
  writeStructBegin oprot "Condition"
  case f_Condition_column record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("column",T_STRING,1)
    writeString oprot _v
    writeFieldEnd oprot}
  case f_Condition_comparisonFunction record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("comparisonFunction",T_I32,2)
    writeI32 oprot (fromIntegral $ fromEnum _v)
    writeFieldEnd oprot}
  case f_Condition_value record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("value",T_STRUCT,3)
    write_ColumnValue oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_Condition_fields iprot record = do
  (_,_t47,_id48) <- readFieldBegin iprot
  if _t47 == T_STOP then return record else
    case _id48 of 
      1 -> if _t47 == T_STRING then do
        s <- readString iprot
        read_Condition_fields iprot record{f_Condition_column=Just s}
        else do
          skip iprot _t47
          read_Condition_fields iprot record
      2 -> if _t47 == T_I32 then do
        s <- (do {i <- readI32 iprot; return $ toEnum $ fromIntegral i})
        read_Condition_fields iprot record{f_Condition_comparisonFunction=Just s}
        else do
          skip iprot _t47
          read_Condition_fields iprot record
      3 -> if _t47 == T_STRUCT then do
        s <- (read_ColumnValue iprot)
        read_Condition_fields iprot record{f_Condition_value=Just s}
        else do
          skip iprot _t47
          read_Condition_fields iprot record
      _ -> do
        skip iprot _t47
        readFieldEnd iprot
        read_Condition_fields iprot record
read_Condition iprot = do
  _ <- readStructBegin iprot
  record <- read_Condition_fields iprot (Condition{f_Condition_column=Nothing,f_Condition_comparisonFunction=Nothing,f_Condition_value=Nothing})
  readStructEnd iprot
  return record
data Query = Query{f_Query_columnExpressions :: Maybe (Vector.Vector ColumnExpression),f_Query_table :: Maybe Text,f_Query_timeStart :: Maybe Int64,f_Query_timeEnd :: Maybe Int64,f_Query_conditions :: Maybe (Vector.Vector Condition),f_Query_groupBy :: Maybe (Vector.Vector Text),f_Query_orderBy :: Maybe Int32,f_Query_limit :: Maybe Int32} deriving (Show,Eq,Typeable)
instance Hashable Query where
  hashWithSalt salt record = salt   `hashWithSalt` f_Query_columnExpressions record   `hashWithSalt` f_Query_table record   `hashWithSalt` f_Query_timeStart record   `hashWithSalt` f_Query_timeEnd record   `hashWithSalt` f_Query_conditions record   `hashWithSalt` f_Query_groupBy record   `hashWithSalt` f_Query_orderBy record   `hashWithSalt` f_Query_limit record  
write_Query oprot record = do
  writeStructBegin oprot "Query"
  case f_Query_columnExpressions record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("columnExpressions",T_LIST,1)
    (let f = Vector.mapM_ (\_viter51 -> write_ColumnExpression oprot _viter51) in do {writeListBegin oprot (T_STRUCT,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_Query_table record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("table",T_STRING,2)
    writeString oprot _v
    writeFieldEnd oprot}
  case f_Query_timeStart record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("timeStart",T_I64,3)
    writeI64 oprot _v
    writeFieldEnd oprot}
  case f_Query_timeEnd record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("timeEnd",T_I64,4)
    writeI64 oprot _v
    writeFieldEnd oprot}
  case f_Query_conditions record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("conditions",T_LIST,5)
    (let f = Vector.mapM_ (\_viter52 -> write_Condition oprot _viter52) in do {writeListBegin oprot (T_STRUCT,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_Query_groupBy record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("groupBy",T_LIST,6)
    (let f = Vector.mapM_ (\_viter53 -> writeString oprot _viter53) in do {writeListBegin oprot (T_STRING,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_Query_orderBy record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("orderBy",T_I32,7)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_Query_limit record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("limit",T_I32,8)
    writeI32 oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_Query_fields iprot record = do
  (_,_t55,_id56) <- readFieldBegin iprot
  if _t55 == T_STOP then return record else
    case _id56 of 
      1 -> if _t55 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) ((read_ColumnExpression iprot)) in do {(_etype60,_size57) <- readListBegin iprot; f _size57})
        read_Query_fields iprot record{f_Query_columnExpressions=Just s}
        else do
          skip iprot _t55
          read_Query_fields iprot record
      2 -> if _t55 == T_STRING then do
        s <- readString iprot
        read_Query_fields iprot record{f_Query_table=Just s}
        else do
          skip iprot _t55
          read_Query_fields iprot record
      3 -> if _t55 == T_I64 then do
        s <- readI64 iprot
        read_Query_fields iprot record{f_Query_timeStart=Just s}
        else do
          skip iprot _t55
          read_Query_fields iprot record
      4 -> if _t55 == T_I64 then do
        s <- readI64 iprot
        read_Query_fields iprot record{f_Query_timeEnd=Just s}
        else do
          skip iprot _t55
          read_Query_fields iprot record
      5 -> if _t55 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) ((read_Condition iprot)) in do {(_etype65,_size62) <- readListBegin iprot; f _size62})
        read_Query_fields iprot record{f_Query_conditions=Just s}
        else do
          skip iprot _t55
          read_Query_fields iprot record
      6 -> if _t55 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) (readString iprot) in do {(_etype70,_size67) <- readListBegin iprot; f _size67})
        read_Query_fields iprot record{f_Query_groupBy=Just s}
        else do
          skip iprot _t55
          read_Query_fields iprot record
      7 -> if _t55 == T_I32 then do
        s <- readI32 iprot
        read_Query_fields iprot record{f_Query_orderBy=Just s}
        else do
          skip iprot _t55
          read_Query_fields iprot record
      8 -> if _t55 == T_I32 then do
        s <- readI32 iprot
        read_Query_fields iprot record{f_Query_limit=Just s}
        else do
          skip iprot _t55
          read_Query_fields iprot record
      _ -> do
        skip iprot _t55
        readFieldEnd iprot
        read_Query_fields iprot record
read_Query iprot = do
  _ <- readStructBegin iprot
  record <- read_Query_fields iprot (Query{f_Query_columnExpressions=Nothing,f_Query_table=Nothing,f_Query_timeStart=Nothing,f_Query_timeEnd=Nothing,f_Query_conditions=Nothing,f_Query_groupBy=Nothing,f_Query_orderBy=Nothing,f_Query_limit=Nothing})
  readStructEnd iprot
  return record
data ResponseValue = ResponseValue{f_ResponseValue_stringValue :: Maybe Text,f_ResponseValue_intValue :: Maybe Int64,f_ResponseValue_stringSet :: Maybe (Set.HashSet Text),f_ResponseValue_stringVector :: Maybe (Vector.Vector Text),f_ResponseValue_doubleValue :: Maybe Double,f_ResponseValue_isNull :: Maybe Bool} deriving (Show,Eq,Typeable)
instance Hashable ResponseValue where
  hashWithSalt salt record = salt   `hashWithSalt` f_ResponseValue_stringValue record   `hashWithSalt` f_ResponseValue_intValue record   `hashWithSalt` f_ResponseValue_stringSet record   `hashWithSalt` f_ResponseValue_stringVector record   `hashWithSalt` f_ResponseValue_doubleValue record   `hashWithSalt` f_ResponseValue_isNull record  
write_ResponseValue oprot record = do
  writeStructBegin oprot "ResponseValue"
  case f_ResponseValue_stringValue record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("stringValue",T_STRING,1)
    writeString oprot _v
    writeFieldEnd oprot}
  case f_ResponseValue_intValue record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("intValue",T_I64,2)
    writeI64 oprot _v
    writeFieldEnd oprot}
  case f_ResponseValue_stringSet record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("stringSet",T_SET,3)
    (let {f [] = return (); f (_viter74:t) = do {writeString oprot _viter74;f t}} in do {writeSetBegin oprot (T_STRING,fromIntegral $ Set.size _v); f (Set.toList _v);writeSetEnd oprot})
    writeFieldEnd oprot}
  case f_ResponseValue_stringVector record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("stringVector",T_LIST,4)
    (let f = Vector.mapM_ (\_viter75 -> writeString oprot _viter75) in do {writeListBegin oprot (T_STRING,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_ResponseValue_doubleValue record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("doubleValue",T_DOUBLE,5)
    writeDouble oprot _v
    writeFieldEnd oprot}
  case f_ResponseValue_isNull record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("isNull",T_BOOL,6)
    writeBool oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_ResponseValue_fields iprot record = do
  (_,_t77,_id78) <- readFieldBegin iprot
  if _t77 == T_STOP then return record else
    case _id78 of 
      1 -> if _t77 == T_STRING then do
        s <- readString iprot
        read_ResponseValue_fields iprot record{f_ResponseValue_stringValue=Just s}
        else do
          skip iprot _t77
          read_ResponseValue_fields iprot record
      2 -> if _t77 == T_I64 then do
        s <- readI64 iprot
        read_ResponseValue_fields iprot record{f_ResponseValue_intValue=Just s}
        else do
          skip iprot _t77
          read_ResponseValue_fields iprot record
      3 -> if _t77 == T_SET then do
        s <- (let {f 0 = return []; f n = do {v <- readString iprot;r <- f (n-1); return $ v:r}} in do {(_etype82,_size79) <- readSetBegin iprot; l <- f _size79; return $ Set.fromList l})
        read_ResponseValue_fields iprot record{f_ResponseValue_stringSet=Just s}
        else do
          skip iprot _t77
          read_ResponseValue_fields iprot record
      4 -> if _t77 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) (readString iprot) in do {(_etype87,_size84) <- readListBegin iprot; f _size84})
        read_ResponseValue_fields iprot record{f_ResponseValue_stringVector=Just s}
        else do
          skip iprot _t77
          read_ResponseValue_fields iprot record
      5 -> if _t77 == T_DOUBLE then do
        s <- readDouble iprot
        read_ResponseValue_fields iprot record{f_ResponseValue_doubleValue=Just s}
        else do
          skip iprot _t77
          read_ResponseValue_fields iprot record
      6 -> if _t77 == T_BOOL then do
        s <- readBool iprot
        read_ResponseValue_fields iprot record{f_ResponseValue_isNull=Just s}
        else do
          skip iprot _t77
          read_ResponseValue_fields iprot record
      _ -> do
        skip iprot _t77
        readFieldEnd iprot
        read_ResponseValue_fields iprot record
read_ResponseValue iprot = do
  _ <- readStructBegin iprot
  record <- read_ResponseValue_fields iprot (ResponseValue{f_ResponseValue_stringValue=Nothing,f_ResponseValue_intValue=Nothing,f_ResponseValue_stringSet=Nothing,f_ResponseValue_stringVector=Nothing,f_ResponseValue_doubleValue=Nothing,f_ResponseValue_isNull=Nothing})
  readStructEnd iprot
  return record
data QueryResponse = QueryResponse{f_QueryResponse_code :: Maybe Int32,f_QueryResponse_message :: Maybe Text,f_QueryResponse_rows :: Maybe (Vector.Vector (Vector.Vector ResponseValue))} deriving (Show,Eq,Typeable)
instance Hashable QueryResponse where
  hashWithSalt salt record = salt   `hashWithSalt` f_QueryResponse_code record   `hashWithSalt` f_QueryResponse_message record   `hashWithSalt` f_QueryResponse_rows record  
write_QueryResponse oprot record = do
  writeStructBegin oprot "QueryResponse"
  case f_QueryResponse_code record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("code",T_I32,1)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_QueryResponse_message record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("message",T_STRING,2)
    writeString oprot _v
    writeFieldEnd oprot}
  case f_QueryResponse_rows record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("rows",T_LIST,3)
    (let f = Vector.mapM_ (\_viter91 -> (let f = Vector.mapM_ (\_viter92 -> write_ResponseValue oprot _viter92) in do {writeListBegin oprot (T_STRUCT,fromIntegral $ Vector.length _viter91); f _viter91;writeListEnd oprot})) in do {writeListBegin oprot (T_LIST,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_QueryResponse_fields iprot record = do
  (_,_t94,_id95) <- readFieldBegin iprot
  if _t94 == T_STOP then return record else
    case _id95 of 
      1 -> if _t94 == T_I32 then do
        s <- readI32 iprot
        read_QueryResponse_fields iprot record{f_QueryResponse_code=Just s}
        else do
          skip iprot _t94
          read_QueryResponse_fields iprot record
      2 -> if _t94 == T_STRING then do
        s <- readString iprot
        read_QueryResponse_fields iprot record{f_QueryResponse_message=Just s}
        else do
          skip iprot _t94
          read_QueryResponse_fields iprot record
      3 -> if _t94 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) ((let f n = Vector.replicateM (fromIntegral n) ((read_ResponseValue iprot)) in do {(_etype104,_size101) <- readListBegin iprot; f _size101})) in do {(_etype99,_size96) <- readListBegin iprot; f _size96})
        read_QueryResponse_fields iprot record{f_QueryResponse_rows=Just s}
        else do
          skip iprot _t94
          read_QueryResponse_fields iprot record
      _ -> do
        skip iprot _t94
        readFieldEnd iprot
        read_QueryResponse_fields iprot record
read_QueryResponse iprot = do
  _ <- readStructBegin iprot
  record <- read_QueryResponse_fields iprot (QueryResponse{f_QueryResponse_code=Nothing,f_QueryResponse_message=Nothing,f_QueryResponse_rows=Nothing})
  readStructEnd iprot
  return record
data PingResponse = PingResponse{f_PingResponse_code :: Maybe Int32,f_PingResponse_message :: Maybe Text} deriving (Show,Eq,Typeable)
instance Hashable PingResponse where
  hashWithSalt salt record = salt   `hashWithSalt` f_PingResponse_code record   `hashWithSalt` f_PingResponse_message record  
write_PingResponse oprot record = do
  writeStructBegin oprot "PingResponse"
  case f_PingResponse_code record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("code",T_I32,1)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_PingResponse_message record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("message",T_STRING,2)
    writeString oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_PingResponse_fields iprot record = do
  (_,_t109,_id110) <- readFieldBegin iprot
  if _t109 == T_STOP then return record else
    case _id110 of 
      1 -> if _t109 == T_I32 then do
        s <- readI32 iprot
        read_PingResponse_fields iprot record{f_PingResponse_code=Just s}
        else do
          skip iprot _t109
          read_PingResponse_fields iprot record
      2 -> if _t109 == T_STRING then do
        s <- readString iprot
        read_PingResponse_fields iprot record{f_PingResponse_message=Just s}
        else do
          skip iprot _t109
          read_PingResponse_fields iprot record
      _ -> do
        skip iprot _t109
        readFieldEnd iprot
        read_PingResponse_fields iprot record
read_PingResponse iprot = do
  _ <- readStructBegin iprot
  record <- read_PingResponse_fields iprot (PingResponse{f_PingResponse_code=Nothing,f_PingResponse_message=Nothing})
  readStructEnd iprot
  return record
